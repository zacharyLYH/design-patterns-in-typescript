# Overview

The Composite pattern is one of the more interesting patterns. The Composite pattern allows treating individual objects and groups of objects uniformly by sharing a common interface or base type. It enables hierarchical structures and recursive operations. The premise of this pattern is to put 2 or more different types into the same container, whereby the type of the container is also a type of one of the items. Say we have type `A`, `B`, `C`, then we might put all 3 types into a container of type `C`. As you can see, it is quite magical. The secret is that all 3 types actually share a common base type. And since all 3 types share the same base type, they can go into a container that is compatible with the base type (ie. any one of the 3 types or the base type).

One can imagine that this pattern could be useful if you want to put objects of different type into the same container. Whats truly powerful is that you can put an object of type `C` into a container of type `C` too, opening up the door to very robust possibilities.

The pitfall to this pattern is obviously the shared base type. 3 types, `A`, `B`, `C`, very likely have some common methods, but even more likely to have methods that aren't unanimously shared. For example, type `B` might share 3/5 methods with type `A`, but 2 methods they don't share. The base type has to define all the methods `A`, `B`, `C` need to use. A typical implementation in the base type is to provide a default implementation for each method the base type defines, then let each method `method override` the base implementation with an implementation it requires. When each type inherits the base type, via inheritance rules they'll also be able to access those methods which their implementation does not need. (It should be mentioned the examples listed currently throw an Error as a default implementation).

# Examples

### head-first-nested-menu-example.ts

-   In this example, we have 4 composite menus; 3 "actual" menus and 1 "collection of the 3 actual menus" menu. Sounds complicated, what's going on? How did we nest 3 menus into 1 menu, well, _all 4 menus are the same type_. Like putting a medium size box within another medium size box, logically this seems impossible! Let's not dwell on the box analogy.
-   Let's get it out there: all 4 composite menus are type `MenuGroup`. The `MenuGroup` defines the operations you can perform on a group of `MenuItems`. Makes sense. You may add and remove `MenuItems`, and these functionalities should belong to the group "owner" (`MenuGroup`). We haven't answered the question: how can you treat a collection of items and an item itself the same (storing it in a same data structure)? The answer is: by making the item (`MenuItem`) **and** the collection of items (`MenuGroup`) be of the same **base** type (`MenuComponent`)!
-   What does making the item itself and the collection of items both a base type of `MenuComponent` achieve? Well, to the compiler, these constructs are the same, in other words, `MenuGroup` and `MenuItem` are the same (base) type (`MenuComponent`) and thus can go into the same data structure. Remember the perculiarity earlier: A menu type houses other menus, like a medium size box housing other medium sized boxes - it didn't make sense. Here's the trick: Since all `MenuGroup` are actually a `MenuComponent` under the hood, we can create an array that takes elements of type `MenuComponent` (the whole menu, and individual menu items)! No magic, just polymorphism!
-   Just to recap: Everything (the whole menu and individual items) are `MenuComponents` under the hood. Since both `MenuItem` and `MenuGroup` are the same underlying type, they can sit in a collection of type `MenuComponent` together!
-   In line 158, `allMenus` can be type `MenuGroup` indeed, but if it helps clarity, this line of code also works: `const allMenus: MenuComponent = new MenuGroup("All Menus", "All menus combined");`

### file-system.ts

-   This example is ultra boiled down, however as per the theme of our self-written examples, we want them to be easy to understand yet (at least mildy) interesting!
-   First, we create an instance of `MockFolder`, because all files and folders have to go into some folder no matter what. Next, we added 2 files into the folder. These 2 files are an instance of `MockFile`. Note that at this point, all 3 items, files and folder, share a base type of `FileSystemComponents`.
-   Next, we created another folder called `folder2`. This folder is also a base type of `FileSystemComponents`. Thus far we have 4 `FileSystemComponents`, 2 of them concrete `MockFile`s and the other 2 are concrete `MockFolder`s. Since they all share the same base type, the data structure `folderContents` of type `FileSystemComponents` can house all these items!
